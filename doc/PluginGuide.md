# MultiMon Plugin Guide

![](images/PluginSplash.png)

## Introduction

*MultiMon* contains the beginning of a Plugin system which supports expansion and customization in a no-code or low-code manner. Without any code a plugin can add a new screen to the GUI which presents existing information (e.g. temperature or printer status) information in a custom layout. With code, plugins may also add new data sources (e.g. readings from a locally attached sensor or data gathered from a REST API). For example, you may want a screen that contains a specific set of information in a specific layout that suits your needs. *MultiMon* ships with a couple of example plugins that you can use to help create your own.

Plugins are largely declarative, using JSON files to describe the GUI they present on the attached display, their settings, the Web form to display/edit the settings, and references to the data they consume. 

You can have many instances of the same type of plugin or of different types of plugin. At the moment, *MultiMon* allows up to four plugins but this is a somewhat arbitrary limit. More could be added if memory allows.

***NOTE***: This document is just as nascent as the Plugin system itself. Looking at the examples will be required to understand the mechanism.

### Dependencies
The Web UI page used to display plugin settings is based on [JSON Form](https://github.com/jsonform/jsonform). It has a number of dependencies on various CSS and Javascript files.
You do not need to install these files used in the browser. None of this is used directly by MultiMon. This list is providde for information only.

* [JSON Form](https://github.com/jsonform/jsonform)
* [JQuery](https://github.com/jquery/jquery)
* [Underscore.js](https://github.com/jashkenas/underscore)
* [Bootstrap](https://github.com/twbs/bootstrap) (CSS file only): *MultiMon* uses a customized version which allows pages generated by [JSON Form](https://github.com/jsonform/jsonform) to coexist with the [W3.CSS](https://www.w3schools.com/w3css/defaulT.asp) styles used elsewhere in the Web UI. The custom CSS file is hosted [here](https://jpasqua.github.io/static/bootstrap-3.3.7-iso.css) and is version 3.3.7.

## Structure of Plugins

A plugin consists of a number of JSON descriptors described below, and optionally C++ code for any deeper customizations. To create a no-code plugin (called a Generic plugin), only the JSON files are needed.

<a name="descriptors"></a>
### JSON Descriptors

Each plugin requires four JSON descriptor files. All descriptors for a plugin are placed in a subdirectory of `/data/plugins` which can have any name you'd like. The directory name is not germane to the plugin. The four JSON files are listed below and must have these names:

* **plugin.json**: A simple file which gives:
  * The display name of the plugin
  * The plugin type. The type must either be "generic" for no-code plugins, or must correspond to a name you've given in your custom code.
  * A namespace. If this plugin makes data available to other plugins, the namespace is used to reference it. See the section on [data values](#datavalues).
* **settings.json**: If the plugin has settings, for example an API key for a REST service it uses, they are given in this file. This is very much like the main *MultiMon* settings file, but the contents are up to the plugin developer. For generic (no-code) plugins, there are just a few settings:
	* Whether the plugin is enabled
	* How often to refresh the UI
	* A representation of the units of the refresh interval (i.e. is it seconds, minutes, etc.)
* **form.json**: A [jsonform](https://github.com/jsonform/jsonform) descriptor that is used by the Web UI to allow the user to display and edit the settings. Using this mechanism, a plugin can augment *MultiMon*'s Web UI without creating a new HTML template or writing custom code. The Web UI for all plugins are displayed by the [Configure Plugins](../Readme.md#configure-plugins) page 
* **screen.json**: A description of the layout and content of the screen. The FlexScreen class is responsible for parsing this description and displaying information - no custom code is required. FlexScreen can display things like floats, ints, and string using a format you specify. It can also display more complex things like a progress/status bar. At the moment, that's the only complex thing.

### Custom Code

You can create a plugin that goes beyond what is possible via a generic plugin. There are two types of code that may be involved in a custom plugin: the plugin itself and one or more data sources:

* **The plugin code**: The plugin code is a subclass of the built-in Plugin class. It is typically fairly simple and is responsible for a few things:
  * Serializing and Deserializing any custom settings from the settings.json file. This is fairly mechanical and can be copied and customized from one of the example plugins.
  * Mapping names to values. When you are describing your screen layout in the screen.json file, each field has a key. That key is a string that names the data value to be displayed. It is up to the plugin code to handle requests to map keys to actual values. For example, a key might be "headline" and the plugin might map that to a value from a news source which provides top headlines.
* **Data sources**: A data source is any code that makes data available for use by one or more plugins. This could be something that reads information from local sensors, a remote device, a news service - whatever. It is responsible for getting the data and providing an API for consuming it.

Plugin code should be placed in the `src/plugins` directory and the data sources should be placed  in the `src/clients` directory.

## Describing the GUI Layout

A major part of the plugin is the screen it displays in the GUI. This is defined in the `screen.json` file. The overall structure is:

````
{
  "items": [ { }, ... { } ],
  "bkg": "0x000000",
  "name": "Displayed Name"
}
````
The bulk of the content is in the `items` array, each element of which describes an item that is displayed on the screen. I sometimes refer to this as a field. An item may be static content, like a label, or it may be a reference to some value. Before going into the details of items, there are two other simple elements:

* `bkg`: Provide the background color of the screen as a 24bit hex color code
* `name`: The name that will be used to identify the plugin in the GUI and Web UI. This should be a fairly short name as space is limited in the GUI.

The `items` have a number of elements, some of which are optional:

````
{
  "x": 86,  "y": 35,
  "w": 117,  "h": 26,
  "xOff": 58, "yOff": 13,
  "justify": "MC",
  "font": "SB9",
  "color": "0xFFFFFF",
  "format": "%s",
  "strokeWidth": 2
  "type": "STRING",
  "key": "stress"
}
````

The elements are as follows:

* `x, y, w, h`: *Required*. These provide the size and location of the field on the display. The location (0, 0) represents the upper left corner of the display. Note that displayed values are not clipped to the bounding box defined by `w, h`. 
* `xOff, yOff	`: *Optional*. Gives the offset within the bounding box where the content will be rendered. If not specified, it will default to (0, 0).
* `justify`: *Optional*. Defines the alignment of the displayed content within the field. For example, if you would like the content to be centered horizontally and vertical within the field's bounding box, then set `(xOff, yOff)` to `(width/2, height/2)` and use `MC` as the `justify` value.
  
  Allowed values are:
  * TL: Top Left
  * TC: Top Center
  * TR: Top Right
  * ML: Middle Left
  * MC: Middle Center
  * MR: Middle Left
  * BL: Bottom Left
  * BC: Bottom Center
  * BR: Bottom Right

  If not specified, it will default to `TL`. 
* `font`: *Optional*. The font to be used. The structure of the names are: `Family` `Style` `Size`. The families are Mono (M), SansSerif (S), Digital (D). The styles are Regular (default), Bold (B), Oblique (O), and Bold-Oblique (BO). The allowed values are:
  * M9, MB9, MO9, MBO9: 9 point Mono fonts in all styles
  * S9, SB9, SO9, SBO9: point Sans fonts in all styles
  * S12, SB12, SO12, SBO12: 12 point Sans fonts in all styles
  * S18, SB18, SO18, SBO18: 18 point Sans fonts in all styles
  * S24, SB24, SO24, SBO24: 24 point Sans fonts in all styles
  * D20, D72, D100: 7-Segment Digital Font in large sizes
  
  `font` may also be a number corresponding to a built-in font in the [TFT\_eSPI](https://github.com/Bodmer/TFT_eSPI). If this item is omitted, it defaults to built-in font 2.
* `color`: *Required*. The color of the content of the field. This is a 24-bit (888) hex color specifier (not a name) which may begin with `#` or `0x`.
* `format`: *Required*. The format is used to display the content of the field. It is a `printf` style format. For example if the field is meant to display a temperature, then the format might be: `"Temp: %0.1fF"`. If the field is just a static label, then the format specifies the label. Note: while optional, if this is not supplied, then no content will be displayed other than a border if specified.   The `format` must correspond to the `type`. For example, if the `type` is `FLOAT`, then the `format` must include some variation of `%f`. 
  There are special values of the format string that begin with '#'. These format strings indicate that a a custom display element should be used rather than displaying the result textually. The current set of custom display elements are:
  * `#progress`: Display a progress bar.
* `strokeWidth`: *Optional*. If supplied it specifies the size of a border to be drawn around (inside of) the bounding box. If not supplied, then no border will be drawn.
* `type`: *Optional*. Specifies the type of the value to be displayed in the field.
  * Allowed values are: `INT`, `FLOAT`, `STRING`, `BOOL`.
  * All of the previous types refer to single values. There are a few pre-defined types which are composite values:
      * `CLOCK`: This is a composite of three INT values representing an hour, minute, and second. A value of this type should be used with a format such as `%2d:%02d:%02d`, which would display the hour, minute, and seconds. You could also use `%2d:%02d`, which would display only the hour and minute.
      * `STATUS`: This composite type consists of an `INT` and a `STRING`. For example they might be a status code and a message. The associated format must have the `%s` for the message before the `%d` for the code. For example: `"Error %s (%d)"`.
      * A value of this type may also be used in conjunction with the `#progress` format which will display a progress bar.
* `key`: The name of a data value that should be supplied by the Plugin framework when the screen is displayed. Allowed values are defined by the custom Plugin code ***or*** a system value may be used (see [below]()). For example, a custom Plugin that reads sensor data might have a value called "stress". This name may be used as a key.

<a name="datavalues"></a>
## Data Values

Any plugin (generic or custom) may access values made available by an app-wide data broker. Values are provided by a number of built-in sources, but can also be provided by plugins and their associated data providers.  For example, the Blynk Weather plugin example makes all of its data available to other plugins.

Values have names that are composed of multiple parts. All keys begin with a '$' followed by a single letter:

* `$S`: Corresponds to the system namespace which contains keys for things like the current time and heap statistics
* `$P`: Corresponds to the printer namespace which contains keys related to the printers being monitored such as the printing status and percent complete.
* `$W`: Corresponds to the weather namespace which contains keys such as the temperature in the selected city.
* `$E`: Corresponds to the ***extension*** namespace which is where plugins can publish their own data values.

The list of available values for `$S`, `$P`, and `$W` are given in the table below.


| Full name | Type 	  | Description	|
|-----------|:-------:|------------	|
| **System**    |         |	             |
| `$S.author` | STRING  | MultiMon's author                 |
| `$S.heap`   | STRING  | Heap free space and fragmentation |
| `$S.time`   | CLOCK   | The current time |
| **Weather**   |   | |
| `$W.temp`   | FLOAT   | Current temperature |
| `$W.desc`   | STRING  | Short description of weather conditions  |
| `$W.ldesc`  | STRING  | Longer description of weather conditions |
| **Printers**   |   | |
| `$P.next`  | STRING | A composite string giving the name of the printer that will complete a job next and the time at which it will be complete|
|   |  **Note** | To get data about a specific printer, use a key of the form: `$P.N.key` where `N` is a number form 1-4 which specifies the printer of interest.
| `$P.N.name`  | STRING | Nickname of the printer. If no nickname was set, the hostname will be returned. This could be in the form of an IP address. |
| `$P.N.pct`  | INT | If the printer is active and printer, the returned INT will be the percentage complete (0-100). If the printer is either no active or not printing, an empty string will be returned. |
| `$P.N.status`  | STATUS | The status of the printer and percent complete (0-100). If there is a print in progress, only the status part of the result will be empty and the percentage will reflect the percent complete. Otherwise the percentage will be 100 and the status will be either "Offline", "Online", or "Complete". |

Any plugin that publishes data should provide a similar list of available data. See the [Blynk Weather Plugin](#bwp) for an example.


## Plugin Examples

MultiMon has two example plugins: one custom and one generic. All of the JSON descriptor files for these plugins are in the `data/plugins/` directory, but the settings files are named `sample.json` rather than `settings.json`. Without a valid settings file, neither will load. If you'd like to experiment with plugins, simply rename the `sample.json` to `settings.json`.

<a name="bwp"></a>
### The Blynk Weather Plugin Example

The Blynk Weather Plugin is an example of a custom plugin that provides a new data source and custom plugin code. The new data source is for the [Blynk](https://blynk.io) service. In this example a weather station such as [JAWS](https://github.com/jpasqua/JAWS) writes readings like temperature and humidity to the Blynk service. The Blynk Weather plugin collects data from up to two weather stations and displays the information in a new screen:

![](images/ss/BlynkScreen.png)

This plugin consists of the following files:

* `src/clients/BlynkClient.[cpp,h]`: The client code that reads data from the Blynk service that was written there by a weather station. Though BlynkClient is used by the BlynkWeather plugin, it can also be used by any plugin that wants to read arbitrary information from Blynk.
* `src/plugins/BlynkPlugin.[cpp,h]`: The custom plugin code that manages settings and maps names to values. 
* `data/plugins/blynk1/*.json`: The JSON plugin descriptors as [described above](#descriptors).

This plugin has a number of settings that need to be specified by the user such as the Blynk IDs associated with the two weather stations and nicknames for each station that will be displayed in the GUI. The `form.json` file describes the web form that will be used to present the settings to the user. [jsonform](https://github.com/jsonform/jsonform) is a very rich tool that is well described on github. Please refer to its [wiki](https://github.com/jsonform/jsonform/wiki) to learn more.

To use this plugin you would have to have a a weather system that publishes data out to Blynk. However, the plugin can be easily adapted to other sensor data that is available through the Blynk service.

This example plugin also acts a data source for other plugins. All of the data it retrieves from Blynk can be accessed through the [data broker](#datavalues). The plugin uses the `BW` namespace, so to access Blynk Virtual pin 0 on device 0, the full key would be `$E.BW.0/V0`:

* `$E.` means this is a request for data from an extension data source (i.e. a plugin)
* `BW.` means get it from the plugin whose namespace was declared to be `BW`
* `0/V0` means Blynk device 0, virtual pin 0. For this example, that is the temperature reading.

The full set of available data is:

| Full name | Type 	  | Description	|
|-----------|:-------:|------------	|
| `$E.BW.NN1`  | STRING  | The nickname for the first Blynk device      |
| `$E.BW.NN2`  | STRING  | The nickname for the second Blynk device     |
| `$E.BW.0/V0` | FLOAT   | The temp reading from the first Blynk device |
| `$E.BW.0/V1` | FLOAT   | The humidity reading from the first Blynk device |
| `$E.BW.0/V2` | FLOAT   | The barometer reading from the first Blynk device |
| `$E.BW.0/V7` | FLOAT   | The battery reading from the first Blynk device |
| `$E.BW.0/V8` | STRING  | The formatted time of the most recent readings from the first Blynk device |
|  | **NOTE**  | All of the same readings are available for the second Blynk device. Just replace the leading 0 with a 1. For example, `$E.BW.0/V1` &rarr; `$E.BW.1/V1` |

### The Generic Plugin Example

The generic plugin example shows how to create a custom screen with your own layout that displays existing data from the [system or any other plugin](#datavalues). In this case, there is no code - just the JSON descriptor files.

![](images/ss/GenericPluginScreen.png)

Some things to notice in the descriptor files:

* **plugin.json**:
  * The name specified here is the display name. It gets used in the [Utility screen](MultiMonGUI.md/#utility-screen) to label a button and the [plugin settings page](../Readme.md#configure-plugins) in the Web UI.
  * The type is "generic" which tells the system that this is a generic plugin rather than one that requires custom code.
* **screen.json**: The screen layout has examples of left, right, and center-justifying fields. It uses different fonts, different sizes, and different colors. It pulls data from the system namespace, the printer namespace, the weather namespace, and from the Blynk plugin. If you're not using that plugin you can remove those fields. It also uses the `CLOCK` type, the `STATUS` type and the `#progress` format.
* **settings.json**: Generic plugins have four elements in their settings file. Only two are visible to the user:
  * `version`: *Not user visible*. This is the version of the settings structure. It is used internally by the system.
  * `enabled`: *User visible*. Is the plugin enabled? That is, will the user be able to select this plugin in the GUI. 
  * `refreshInterval`: *User visible*. How often the GUI should be updated.
  * `riScale`: *Not User Visible*. The units of `refreshInterval`. Internally all refresh times are represented in milliseconds. If you want the user to operate in seconds, then `riScale` should be 1000 (1000 millis in a second). If you want the user to set values in minutes, then `riScale` should be 60*1000.
* **form.json**: This file describes how the settings should be displayed to the user in the Web UI. A couple of points of interest here:
  * The version setting is not listed at all since it is not sent from the browser to *MultiMon*.
  * The `riScale` field is sent to the server, but the user doesn't see it, so it is declared as hidden.
